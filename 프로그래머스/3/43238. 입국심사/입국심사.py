def solution(n, times):
    # 총 심사 시간을 기준으로 삼는다
    # 각 심사대마다 심사에 걸리는 시간은 다르지만, 결국 심사하는 시간 자체는 모두 같다
    # 때문에 각 심사대마다 정해진 시간 동안 몇 명을 심사했는지 구한 뒤 모두 더하면 총 몇 명을 심사했는지 알 수 있고,
    # 이를 n과 비교하며 start나 end의 범위를 조정하면 된다
    start, end = 1, max(times) * n
    # end 값은 총 심사 시간의 최댓값으로, 가장 심사가 오래 걸리는 심사대에 n명이 모두 심사를 받을 때를 의미한다
    while start <= end:
        total_time = (start + end) // 2 # 총 심사 시간
        finished = 0 # 심사받은 사람 수를 카운트
        for time in times:
            finished += total_time // time
            # 심사대마다 심사한 사람 수 = 총 심사 시간 / 심사대마다 걸리는 시간
            # finished에 계속 업데이트
            if finished >= n:
                break
            # 심사한 사람 수가 n을 넘거나 같은 경우에는 바로 종료한다
            # 사람 수는 이보다 더 커질 일밖에 남지 않았기에 더 진행해도 의미가 없기 때문
            # 작성하지 않아도 상관은 없지만 실행 시간을 줄여준다
        if finished >= n:
            answer = total_time
            end = total_time - 1
            # 심사한 사람 수가 n보다 크다면 시간이 충분해 n명보다 많은 사람을 심사한 경우이다
            # 때문에 시간을 줄이는 방향으로 구간을 조정해야 하므로 end를 감소시킨다
            # finshed가 n보다 크거나 작을 경우는 각각 end와 start를 조정하면 되지만, 서로 같은 경우는 생각해볼 필요가 있다
            # 옆 문제를 예시로 들어보자
            # total_time이 30분인 경우와 28분인 경우 모두 6명의 심사를 끝낼 수 있고, finished = n = 6임을 알 수 있다
            # 다만 이 문제는 최단 시간을 구하는 문제로,
            # 30분일 경우에는 28분으로 시간을 줄여야 하지만 28분일 경우에는 30분으로 시간을 늘릴 필요가 없다
            # 따라서 시간을 줄이는 방향으로 구간을 조정하는 이 부분에 finished = n인 경우를 배정해야 한다
            # finished = n인 경우의 최솟값이 정답이므로 answer 또한 이 부분에서 업데이트 한다
            # 다만 일반적으로 크거나 같은 부분에 정답을 기록하는 형태가 많은 듯 하니 외워서 사용하는 것도 좋아보인다
        else:
            start = total_time + 1
            # 심사한 사람 수가 n보다 작다면 시간이 부족하여 n명을 다 심사하지 못한 경우이다
            # 때문에 start를 증가시켜 시간 또한 증가시킨다
    return answer